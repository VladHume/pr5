# Звіт про дослідження втрати пам’яті в умовах рідкісного гілкування логіки

## Опис сценарію

Було створено [програму](https://github.com/VladHume/pr5/blob/main/task.c), яка виконує мільйон ітерацій функції `process_data`. У цій функції є два гілкування:

- **Основний шлях**: виділяється пам’ять, копіюються дані та пам’ять звільняється.
- **Рідкісний випадок** (умова `RARE_CONDITION`): пам’ять виділяється, але **не звільняється**, що імітує витік пам’яті.

### Код:

```c
if (strstr(input, "RARE_CONDITION")) {
    buffer = (char *)malloc(1024);
    if (!buffer) return;
    strcpy(buffer, input);
    return; // <<< тут відсутній free(buffer);
}
```

Цей код виконується лише тоді, коли рядок містить `"RARE_CONDITION"`, що трапляється раз на 99 991 ітерацію.

## 3. Методика тестування

Для виявлення витоку було використано утиліту **Valgrind** з такими параметрами:

```bash
valgrind --leak-check=full --show-leak-kinds=all ./task
```

## 4. Результати Valgrind
![image](https://github.com/user-attachments/assets/2ae10c12-9d24-4c33-b5f0-52b22a944ea9)


- **Витік пам’яті (definitely lost):**

  ```
  definitely lost: 11,264 bytes in 11 blocks
  ```

- **Місце витоку:**

  ```
  by 0x484D2E4: malloc
  by 0x400735: process_data (in /home/vlad/pr5/task)
  ```

- **Загальна статистика:**

  ```
  total heap usage: 1,000,002 allocs, 999,989 frees
  ```

- **Пояснення:**

  13 блоків залишились у пам’яті, з яких 11 — явні витоки. Це відповідає кількості разів, коли було викликано гілку з `"RARE_CONDITION"`.

## 5. Висновок

- **Проблема:** У функції `process_data`, коли спрацьовує рідкісна умова, пам’ять виділяється, але не звільняється. Це призводить до **витоку пам’яті**.
- **Особливість:** Такий витік може залишитися **непоміченим**, якщо:
  - Тестування охоплює лише основні (часті) гілки логіки.
  - Використовуються лише базові профайлери.
- **Valgrind:** Успішно виявив витік, незважаючи на його рідкість.

